var __index = {"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Pignio","text":""},{"location":"index.html#pignio","title":"Pignio","text":"<p>Pignio is your personal self-hosted media pinboard, built on top of flat-file storage.</p> GitLab.com GitHub Gitea.it <p>You can view a production demo of the latest version of the software at https://pignio.octt.eu.org/.</p> <p></p>"},{"location":"index.html#deploying","title":"Deploying","text":"<ol> <li>Ensure you have the base requirements installed on your system: <code>python</code> and <code>npm</code>.<ul> <li>Additionally, <code>node</code> is needed to render text posts into images correctly, as well as fonts, which must be available for all kinds of characters that might be rendered.<ul> <li>On Windows, all fonts should be available out of the box, while on Linux you might need to install them. On Debian and derivatives, install the <code>fonts-noto</code> metapackage for a nice collection of glyphs, including non-latin scripts and emojis.</li> </ul> </li> <li>Optionally, <code>tesseract</code> and all desired scripts/languages must also be installed, to allow for image OCR.</li> <li>Optionally, to use the audio/video editing features, and generation of GIF video thumbnails, <code>ffmpeg</code> must also be installed.</li> </ul> </li> <li>Get the source code of Pignio: <code>git clone --depth 1 https://gitlab.com/octospacc/Pignio</code> <code>&amp;&amp; cd Pignio</code>.</li> <li>Install all requirements: <code>python -m pip install -r requirements.txt</code> <code>&amp;&amp;</code> <code>npm install</code> (don't forget this last one, otherwise the app will run but the frontend and some features will be broken).</li> <li>Run with <code>python app.py</code>. Optionally, you can edit the configuration file that is automatically created (<code>data/config.ini</code>).</li> </ol> <p>Pignio also runs well on PythonAnywhere, even on the free plan. To deploy it on there, after also installing npm as explained on https://help.pythonanywhere.com/pages/Node/, follow the above standard installation procedure, then create a new webapp with manual setup, and adjust your WSGI configuration file as follows:</p> Python<pre><code>path = '/path/to/your/downloaded/Pignio'\nif path not in sys.path:\n    sys.path.append(path)\nfrom app import app as application\n</code></pre>"},{"location":"index.html#static-site-generation-experimental","title":"Static site generation (Experimental)","text":"<p>You can freeze your entire Pignio instance into a static site, which makes it possible to host it on any basic web server without Python. On a build machine or CI environment, make sure all requirements to normally run the software are satisfied, and that the app works, but then run the <code>freeze.py</code> script. It will generate a <code>build/</code> folder, with all the HTML pages prerendered and all media copied over, that you can then serve as-is or even package to share.</p> <p>You can view a production demo of the static site generation feature at https://pignioctt-9b535e.gitlab.io/index.html. Also take a look at the CI scripts that build the site inside the Git repository: https://gitlab.com/octospacc/pignioctt/.</p>"},{"location":"index.html#http-api","title":"HTTP API","text":"<p>Pignio contains a work-in-progress HTTP JSON API, partly built for use inside the web frontend and partly intended for integration with third-party apps implementing it. Be mindful that methods in the namespace of <code>/api/v0/</code> are intended either for internal use only, or are currently not considered production-ready and are subject to change, so use them at your own risk. All other methods are intended for general use already, listed below.</p> <ul> <li>An example of a practical implementation of the API is available in the WinDog multi-purpose chatbot for saving items via Telegram chats.<ul> <li>You can also test it using the <code>/Pignio</code> command in @WinDogBot.</li> </ul> </li> <li>Please refer to <code>_pignio.py</code> for type definitions for now.</li> <li>To make external calls to the API (when allowed), you need to set a standard <code>Authorization: Bearer &lt;your API token&gt;</code> on your HTTP request.<ul> <li>You can generate API tokens from your user settings page.</li> </ul> </li> </ul>"},{"location":"index.html#items-api","title":"Items API","text":"<ul> <li>GET <code>/api/v1/items/&lt;item_id&gt;</code>: get the full representation of an Item</li> <li>POST <code>/api/v1/items</code> (body = an Item): create a new Item on the server, as specified by the body</li> <li>PUT <code>/api/v1/items/&lt;item_id&gt;</code> (body = an Item): update the specified Item with new provided data</li> <li>DELETE <code>/api/v1/items/&lt;item_id&gt;</code>: delete the specified Item from the server</li> </ul>"},{"location":"index.html#thanks-third-party-libraries","title":"Thanks &amp; Third-Party Libraries","text":"<ul> <li>UIkit for the frontend framework</li> <li>Unpoly for smooth SPA-like navigation</li> <li>model-viewer for displaying of 3D models</li> <li>spessasynth_lib for MIDI playback</li> <li>Ruffle for Shockwave Flash emulation</li> <li>EmulatorJS for emulation of various game consoles</li> </ul>"},{"location":"blog/index.html","title":"Blog","text":""},{"location":"blog/index.html#blog","title":"Blog","text":""},{"location":"docs/Collections.html","title":"Collections","text":"<p>Collections in Pignio, like boards in Pinterest, allow for many items to be grouped together. They are essentially like folders, except user-specific, not dependent on the file system but instead defined by an INI file, and non-exclusive (unlike file folders, an item</p> <p>For each user, the profile itself is a collection, considered the default to save newly-created items to, and it corresponds with the user's profile INI file (<code>/users/&lt;username&gt;.ini</code>). New collections can be created when wanting to save an item, and they correspond with dedicated INI files inside the user's profile-adjacent folder (<code>/users/&lt;username&gt;/&lt;collection&gt;.ini</code>).</p>"},{"location":"docs/Filesystem%20structure.html","title":"Filesystem structure","text":"<p>Being a flat-file software system, Pignio stores all its data into individual files on disk for all its features. This happens in a folder aptly called <code>data</code> in the root directory of the program, and the following is its rough tree diagram.</p> Text Only<pre><code>data\n\u251c\u2500\u2500\u2500config.ini\n\u251c\u2500\u2500\u2500items\n\u2502   \u2514\u2500\u2500\u2500&lt;subfolder&gt;\n\u2502       \u2514\u2500\u2500\u2500&lt;item files&gt;\n\u251c\u2500\u2500\u2500users\n\u2502   \u251c\u2500\u2500\u2500&lt;user&gt;.ini\n\u2502   \u2514\u2500\u2500\u2500&lt;user folder&gt;\n\u2502       \u2514\u2500\u2500\u2500&lt;collections files&gt;\n\u251c\u2500\u2500\u2500cache\n\u2514\u2500\u2500\u2500temp\n</code></pre>"},{"location":"docs/HTTP%20JSON%20API.html","title":"HTTP JSON API","text":"<p>Pignio contains a work-in-progress HTTP JSON API, partly built for use inside the web frontend and partly intended for integration with third-party apps implementing it. Be mindful that methods in the namespace of <code>/api/v0/</code> are intended either for internal use only, or are currently not considered production-ready and are subject to change, so use them at your own risk. All other methods are intended for general use already, listed below.</p> <ul> <li>An example of a practical implementation of the API is available in the WinDog multi-purpose chatbot for saving items via Telegram chats.<ul> <li>You can also test it using the <code>/Pignio</code> command in @WinDogBot.</li> </ul> </li> <li>Please refer to <code>_pignio.py</code> for type definitions for now.</li> <li>To make external calls to the API (when permitted), you need to set a standard <code>Authorization: Bearer &lt;your API token&gt;</code> on your HTTP request.<ul> <li>You can generate API tokens from your user settings page (<code>/settings</code>).</li> </ul> </li> </ul>"},{"location":"docs/HTTP%20JSON%20API.html#items-api","title":"Items API","text":"<ul> <li>GET <code>/api/v1/items/&lt;item_id&gt;</code>: get the full representation of an Item</li> <li>POST <code>/api/v1/items</code> (body = an Item): create a new Item on the server, as specified by the body</li> <li>PUT <code>/api/v1/items/&lt;item_id&gt;</code> (body = an Item): update the specified Item with new provided data</li> <li>DELETE <code>/api/v1/items/&lt;item_id&gt;</code>: delete the specified Item from the server</li> </ul>"},{"location":"docs/Items.html","title":"Items","text":"<p>In Pignio, an item is a single, atomic piece of media or non-media which the app supports for viewing, pinning to collections, and so on.</p>"},{"location":"docs/Items.html#item-formats","title":"Item formats","text":"<p>Various kinds of items are supported, each with specified features and scopes, specified below with the corresponding formats and file extensions.</p> <ul> <li>Images<ul> <li>JPEG (<code>.jpg</code>, <code>.jpeg</code>)</li> <li>JFIF</li> <li>WEBP</li> <li>AVIF</li> <li>Bitmap (<code>.bmp</code>)</li> <li>PNG, APNG</li> <li>GIF</li> <li>SVG</li> </ul> </li> <li>Videos<ul> <li>MP4</li> <li>MPG</li> <li>MOV</li> <li>MKV</li> <li>OGV</li> <li>WEBM</li> </ul> </li> <li>Audios<ul> <li>MP3 (<code>.mp3</code>, <code>.mpeg</code>)</li> <li>M4A</li> <li>OGG</li> <li>OPUS</li> <li>WAV</li> <li>FLAC</li> <li>MIDI (<code>.mid</code>, <code>.midi</code>) with experimental browser support</li> </ul> </li> <li>3D models</li> <li>Fonts<ul> <li>TTF</li> <li>OTF</li> <li>WOFF / WOFF2</li> </ul> </li> <li>Documents<ul> <li>Plaintext (<code>.txt</code>)</li> <li>PDF</li> </ul> </li> <li>Shockwave Flash animations (<code>.swf</code>)</li> <li>Emulator ROMs<ul> <li>NES / FC (<code>.nes</code>)</li> <li>SNES / SFC (<code>.sfc</code>)</li> <li>N64 (<code>.n64</code>, <code>.z64</code>)</li> <li>GB, GBC, GBA</li> <li>NDS</li> </ul> </li> <li>Text on image</li> </ul>"},{"location":"docs/Items.html#item-metadata","title":"Item metadata","text":"<p>All items:</p> <ul> <li><code>title</code>: Optional item title. If not present, the filename or item ID will be used where needed.</li> <li><code>description</code>: Optional additional text to show on the item page, no matter its type. Can contain URLs and hastags, which are automatically linkified where needed.</li> <li><code>alttext</code>: For perceptive media like images or videos, an alternative text to be shown when the media can't be loaded, or for accessibility reasons.</li> <li><code>link</code>: Optional URL specifying the external source of the item.</li> <li><code>creator</code>: Username of the user on the instance which has created the item trough the system.</li> <li><code>systags</code>: WSV list of specific words that the system applies a special meaning to.</li> <li><code>langs</code>: WSV list of languages the content is marked as being in, in the 3-letter language code format. Can be shown to the user in item pages and is needed to run OCR scans on images.</li> <li><code>status</code>: Publication status of the item. Currently supports <code>public</code> and <code>silent</code>. A missing value makes the system use the global default (public).</li> </ul> <p>Text type items:</p> <ul> <li><code>text</code>: The text to use to generate an image.</li> </ul>"},{"location":"docs/Metadata%20format.html","title":"Metadata format","text":"<p>Instead of a traditional table-based database, all application and user data that requires specific fields is stored as simple key-value properties in INI files, which are read and written efficiently by the system, and can also be comfortably edited manually by users.</p> <p>All properties in the INI file are written directly, so without any parent section. The INI dialect used is the one defined by Python, without any interpolation of the values, so:</p> <ul> <li>No whitespace is allowed to the left of keys, when declaring a property.</li> <li>Any text after the key (and the equals symbol <code>=</code>) is interpreted literally, without any obscure escaping rules.</li> <li>Multiline values are supported, by adding whitespace to the left of the lines following the start of a property.</li> <li>Comment lines with the hash symbol (<code>#</code>) are allowed.</li> </ul>"},{"location":"docs/Running.html","title":"Running","text":""},{"location":"docs/Running.html#with-docker-compose","title":"With Docker Compose","text":"<p>A file for deploying Pignio automatically via Docker Compose is provided. You can thus run Pignio on your server in seconds with just the following commands. By default, the software will be exposed on port 5000 of your host, and data will be stored in the local directory <code>data/</code> next to the Docker configuration file.</p> Bash<pre><code>git clone --depth 1 https://gitlab.com/octospacc/Pignio &amp;&amp; cd Pignio\n# optional: edit `docker-compose.yml` as you wish\nsudo docker-compose up -d\n</code></pre>"},{"location":"docs/Running.html#from-source-manually","title":"From source (manually)","text":"<ol> <li>Ensure you have the base requirements installed on your system: <code>python</code> and <code>npm</code>.<ul> <li>Additionally, <code>node</code> is needed to render text posts into images correctly, as well as fonts, which must be available for all kinds of characters that might be rendered.<ul> <li>On Windows, all fonts should be available out of the box, while on Linux you might need to install them. On Debian and derivatives, install the <code>fonts-noto</code> metapackage for a nice collection of glyphs, including non-latin scripts and emojis.</li> </ul> </li> <li>Optionally, <code>tesseract</code> and all desired scripts/languages must also be installed, to allow for image OCR.</li> <li>Optionally, to use the audio/video editing features, and generation of GIF video thumbnails, <code>ffmpeg</code> must also be installed.</li> </ul> </li> <li>Get the source code of Pignio: <code>git clone --depth 1 https://gitlab.com/octospacc/Pignio</code> <code>&amp;&amp; cd Pignio</code>.</li> <li>Install all requirements: <code>python -m pip install -r requirements.txt</code> <code>&amp;&amp;</code> <code>npm install</code> (don't forget this last one, otherwise the app will run but the frontend and some features will be broken).</li> <li>Run with <code>python app.py</code>. Optionally, you can edit the configuration file that is automatically created (<code>data/config.ini</code>).</li> </ol>"},{"location":"docs/Running.html#deploy-on-pythonanywhere","title":"Deploy on PythonAnywhere","text":"<p>Pignio also runs well on PythonAnywhere, even on the free plan. To deploy it on there, after also installing npm as explained on https://help.pythonanywhere.com/pages/Node/, follow the above manual installation procedure, then create a new webapp with manual setup in the PythonAnywhere interface, and adjust your WSGI configuration file as follows:</p> Python<pre><code>path = '/path/to/your/downloaded/Pignio'\nif path not in sys.path:\n    sys.path.append(path)\nfrom app import app as application\n</code></pre>"},{"location":"docs/Static%20site%20generation.html","title":"Static site generation (Experimental)","text":""},{"location":"docs/Static%20site%20generation.html#static-site-generation-experimental","title":"Static site generation (Experimental)","text":"<p>You can freeze your entire Pignio instance into a static site, which makes it possible to host it on any basic web server without Python. On a build machine or CI environment, make sure all requirements to normally run the software are satisfied, and that the app works, but then run the <code>freeze.py</code> script. It will generate a <code>build/</code> folder, with all the HTML pages prerendered and all media copied over, that you can then serve as-is or even package to share.</p> <p>You can view a production demo of the static site generation feature at https://pignioctt-9b535e.gitlab.io/index.html. Also take a look at the CI scripts that build the site inside the Git repository: https://gitlab.com/octospacc/pignioctt/.</p>"},{"location":"docs/Static%20site%20generation.html#quirks","title":"Quirks","text":"<p>The server works with URL paths that have no extra suffixes, eg. no trailing slashes or html extension. However, writing HTML pages to disk for static serving with such naming would prove problematic in many environments, so all page files have an added <code>.html</code> suffix. This is no particular issue, but it means that the expected URLs differ between a Pignio dynamic site and a static one.</p> <p>Given the impossibility to interpret query parameters in the URL, some features are also not available in the static sites and some things might differ, such as:</p> <ul> <li>Pagination is limited to the fixed size specified in the app configuration at build time, and is done via numbers appended to the page name (<code>.2.html</code>, <code>.3.html</code>, ...).</li> <li>Where otherwise reorderable on request between random or not, item lists are forced to be in natural order and are fixed this way.</li> <li>No searching is yet available, as this would need to be reimplemented with custom client-side JavaScript.</li> <li>Support in static sites for specific random things might fall behind in development, and be broken, but overall things should always work.</li> </ul> <p>Additionally, for the moment the generated HTML pages rely on absolute links, so the static website must be hosted on the root of a domain and can't be browsed from the local file system (<code>file://</code>) without a server.</p>"},{"location":"docs/Users.html","title":"Users","text":""},{"location":"docs/Users.html#user-roles","title":"User Roles","text":"<ul> <li>Guest: any user with no account on the app</li> <li>User: any registed user without any specified role, which can create and modify new items and manage personal collections</li> <li>Curator (soon): registered user with the ability to modify all contents of the instance, but without system administration capabilities</li> <li>Admin: registered user with full control over the instance</li> </ul>"}]}